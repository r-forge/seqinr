\documentclass{article}
\input{../config/commontex}

\title{How to deal with sequences}
\author{Charif, D. \and Lobry, J.R.}

\usepackage{/Library/Frameworks/R.framework/Resources/share/texmf/Sweave}
\begin{document}
%
% To change the R input/output style:
%
\definecolor{Soutput}{rgb}{0,0,0.56}
\definecolor{Sinput}{rgb}{0.56,0,0}
\DefineVerbatimEnvironment{Sinput}{Verbatim}
{formatcom={\color{Sinput}},fontsize=\footnotesize, baselinestretch=0.75}
\DefineVerbatimEnvironment{Soutput}{Verbatim}
{formatcom={\color{Soutput}},fontsize=\footnotesize, baselinestretch=0.75}
%
% Rlogo
%
\newcommand{\Rlogo}{\protect\includegraphics[height=1.8ex,keepaspectratio]{../figs/Rlogo.pdf}}
%
% Shortcut for seqinR:
%
\newcommand{\seqinr}{\texttt{seqin\bf{R}}}
\newcommand{\Seqinr}{\texttt{Seqin\bf{R}}}
\fvset{fontsize= \scriptsize}
%
% R output options and libraries to be loaded.
%
%
%  Sweave Options
%
% Put all figures in the fig folder and start the name with current file name.
% Do not produce EPS files
%


\maketitle
% BEGIN - DO NOT REMOVE THIS LINE

\section{Sequence classes}


There are currently three classes of sequences, depending on the way they were obtained:

\begin{itemize}
      \item {\bfseries seqFasta} is the class for the sequences that were imported from a fasta file
      \item {\bfseries seqAcnucWeb} is the class for the sequences coming from an ACNUC database server
      \item {\bfseries seqFrag} is the class for the sequences that are fragments of other sequences
\end{itemize}

\section{Generic methods for sequences}

All sequence classes are sharing a common interface, so that there are very few method names we have to remember. 
In addition, all classes have their specific as.ClassName method that return an instance of the class,
and is.ClassName method to check whether an object belongs or not to the class. 
Available methods are: 
\\
\\
\begin{tabular}{|@{} c @{}|@{} c @{}|@{} c @{}|}
\hline
{\bfseries Methods} & {\bfseries Result} & {\bfseries Type of result} \\
\hline \hline
{\bfseries getFrag} & a sequence fragment & a sequence fragment \\
\hline
{\bfseries getSequence} & the sequence & vector of characters \\
\hline
{\bfseries getName} & the name of a sequence & string \\
\hline
{\bfseries getLength} & the length of a sequence & numeric vector \\
\hline
{\bfseries getTrans} & translation into amino-acids & vector of characters \\
\hline
{\bfseries getAnnot} & sequence annotations & vector of string \\
\hline
{\bfseries getLocation} & position of a Sequence on its parent sequence & list of numeric vector \\
\hline
\end{tabular}

\section{Internal representation of sequences}

The current mode of sequence storage is done with vectors of characters instead of strings.
This is very convenient for the user because all R tools to manipulate vectors are immediatly available. 
The price to pay is that this storage mode is extremly expensive in terms of memory.
They are two utilities called \texttt{s2c()} and \texttt{c2s()} that allows to convert strings into 
vector of characters, and \textit{vice versa}, respectively.

\subsection{Sequences as vectors of characters}

In the vectorial representation mode, all the very convenient R tools for indexing vectors
are at hand.
\begin{enumerate}
\item Vectors can be indexed by a vector of \emph{positive} integers saying which
elements are to be selected. As we have already seen, the first 50 elements of a sequence
are easily extracted thanks to the binary operator \texttt{from:to}, as in:

\begin{Schunk}
\begin{Sinput}
 1:50
\end{Sinput}
\begin{Soutput}
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
[25] 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
[49] 49 50
\end{Soutput}
\begin{Sinput}
 myseq[1:50]
\end{Sinput}
\begin{Soutput}
 [1] "a" "t" "g" "a" "a" "t" "c" "a" "a" "g" "g" "a" "g" "c" "c" "g" "t" "t"
[19] "t" "t" "t" "a" "g" "g" "c" "a" "c" "c" "t" "g" "c" "t" "c" "c" "t" "g"
[37] "g" "t" "g" "c" "t" "g" "c" "a" "g" "c" "t" "g" "g" "t"
\end{Soutput}
\end{Schunk}

The \texttt{seq()} function allows to build more complexe integer vectors. For instance
in coding sequences it is very common to focus on third codon positions where
selection is weak. Let's extract bases from third codon positions:

\begin{Schunk}
\begin{Sinput}
 tcp <- seq(from = 3, to = length(myseq), by = 3)
 tcp[1:10]
\end{Sinput}
\begin{Soutput}
 [1]  3  6  9 12 15 18 21 24 27 30
\end{Soutput}
\begin{Sinput}
 myseqtcp <- myseq[tcp]
 myseqtcp[1:10]
\end{Sinput}
\begin{Soutput}
 [1] "g" "t" "a" "a" "c" "t" "t" "g" "c" "g"
\end{Soutput}
\end{Schunk}
 
 \item Vectors can also be indexed by a vector of \emph{negative} integers saying which
elements have to be removed. For instance, if we want to keep first and second codon positions,
the easiest way is to remove third codon positions:

\begin{Schunk}
\begin{Sinput}
 -tcp[1:10]
\end{Sinput}
\begin{Soutput}
 [1]  -3  -6  -9 -12 -15 -18 -21 -24 -27 -30
\end{Soutput}
\begin{Sinput}
 myseqfscp <- myseq[-tcp]
 myseqfscp[1:10]
\end{Sinput}
\begin{Soutput}
 [1] "a" "t" "a" "a" "c" "a" "g" "g" "g" "c"
\end{Soutput}
\end{Schunk}

\item Vectors are also indexable by a vector of \emph{logicals} whose \texttt{TRUE}
values say which elements to keep. Here is a different way to extract all third coding positions
from our sequence. First, we define a vector of three logicals with only the last one true:

\begin{Schunk}
\begin{Sinput}
 ind <- c(F, F, T)
 ind
\end{Sinput}
\begin{Soutput}
[1] FALSE FALSE  TRUE
\end{Soutput}
\end{Schunk}

This vector seems too short for our purpose because our sequence is much more longer
with its 1425 bases. But under R vectors are automatically \emph{recycled}
when they are not long enough:

\begin{Schunk}
\begin{Sinput}
 (1:30)[ind]
\end{Sinput}
\begin{Soutput}
 [1]  3  6  9 12 15 18 21 24 27 30
\end{Soutput}
\begin{Sinput}
 myseqtcp2 <- myseq[ind]
\end{Sinput}
\end{Schunk}

The result should be the same as previously:

\begin{Schunk}
\begin{Sinput}
 identical(myseqtcp, myseqtcp2)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\end{Schunk}

This recycling rule is extremely convenient in practice but may have surprising
effects if you assume (incorrectly) that there is a stringent dimension control for R vectors
as in linear algebra.

\end{enumerate}

Another advantage of working with vector of characters is that most R functions
are vectorized so that many things can be done without explicit looping. Let's
give some very simple examples:

\begin{Schunk}
\begin{Sinput}
 tota <- sum(myseq == "a")
\end{Sinput}
\end{Schunk}

The total number of \texttt{a} in our sequence is 350. Let's compare
graphically the different base counts in our sequence :

\begin{Schunk}
\begin{Sinput}
 basecount <- table(myseq)
 myseqname <- getName(completeCatsCDS$req[[1]])
 dotchart(basecount, xlim = c(0, max(basecount)), pch = 19, 
     main = paste("Base count in", myseqname))
\end{Sinput}
\end{Schunk}
\includegraphics{../figs/dealseq-vecto2}

\begin{Schunk}
\begin{Sinput}
 dinuclcount <- count(myseq, 2)
 dotchart(dinuclcount[order(dinuclcount)], xlim = c(0, max(dinuclcount)), 
     pch = 19, main = paste("Dinucleotide count in", myseqname))
\end{Sinput}
\end{Schunk}
\includegraphics{../figs/dealseq-vecto3}

\begin{Schunk}
\begin{Sinput}
 codonusage <- uco(myseq)
 dotchart.uco(codonusage, main = paste("Codon usage in", myseqname))
\end{Sinput}
\end{Schunk}
\includegraphics{../figs/dealseq-vecto4}


\subsection{Sequences as strings}

If you are interested in (fuzzy) pattern matching, then it is advisable to work with
sequence as strings to take advantage of \emph{regular expression} implemented
in R. The function \texttt{words.pos()} returns the positions of all occurrences
of a given regular expression. Let's suppose we want to know where are the trinucleotides
"cgt" in a sequence, that is the fragment CpGpT in the direct strand:

\begin{Schunk}
\begin{Sinput}
 mystring <- c2s(myseq)
 words.pos("cgt", mystring)
\end{Sinput}
\begin{Soutput}
[1]   15  854  909  919  987 1248
\end{Soutput}
\end{Schunk}

We can also look for the fragment CpGpTpY to illustrate fuzzy matching because
Y (IUPAC code for pyrimidine) stands C or T:

\begin{Schunk}
\begin{Sinput}
 words.pos("cgt[ct]", mystring)
\end{Sinput}
\begin{Soutput}
[1]  15 909 919
\end{Soutput}
\end{Schunk}

To look for all CpC dinucleotides separated by 3 or 4 bases:
\begin{Schunk}
\begin{Sinput}
 words.pos("cc.{3,4}cc", mystring)
\end{Sinput}
\begin{Soutput}
 [1]   27  121  152  278  431  437  471  476  477  492  555  618  722  788
[15]  809  885  886  939 1043 1046 1190 1220 1263
\end{Soutput}
\end{Schunk}

Virtually any pattern is easily encoded with a regular expression. This is
especially useful at the protein level because many functions can be attributed 
to short linear motifs.

% END - DO NOT REMOVE THIS LINE

%%%%%%%%%%%%  BIBLIOGRAPHY %%%%%%%%%%%%%%%%%
\clearpage
\addcontentsline{toc}{section}{References}
\bibliographystyle{plain}
\bibliography{../config/book}
\end{document}
