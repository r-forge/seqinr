\documentclass{article}
\input{../config/commontex}

\title{Importing zlib-compressed sequences}

\author{Lobry, J.R.}

\usepackage{/Library/Frameworks/R.framework/Resources/share/texmf/Sweave}
\begin{document}
%
% To change the R input/output style:
%
\definecolor{Soutput}{rgb}{0,0,0.56}
\definecolor{Sinput}{rgb}{0.56,0,0}
\DefineVerbatimEnvironment{Sinput}{Verbatim}
{formatcom={\color{Sinput}},fontsize=\footnotesize, baselinestretch=0.75}
\DefineVerbatimEnvironment{Soutput}{Verbatim}
{formatcom={\color{Soutput}},fontsize=\footnotesize, baselinestretch=0.75}
%
% Rlogo
%
\newcommand{\Rlogo}{\protect\includegraphics[height=1.8ex,keepaspectratio]{../figs/Rlogo.pdf}}
%
% Shortcut for seqinR:
%
\newcommand{\seqinr}{\texttt{seqin\bf{R}}}
\newcommand{\Seqinr}{\texttt{Seqin\bf{R}}}
\fvset{fontsize= \scriptsize}
%
% R output options and libraries to be loaded.
%
%
%  Sweave Options
%
% Put all figures in the fig folder and start the name with current file name.
% Do not produce EPS files
%


\maketitle
\tableofcontents
% BEGIN - DO NOT REMOVE THIS LINE
\label{extractseqs}
\section{Introduction}

There are two functions to get the sequences from an ACNUC server. 
The first one, \texttt{getSequence()}, uses regular socket connections, the
second one, \texttt{extractseqs()}, uses zlib compressed sockets,
which is faster but the function is experimental and has not
been extensively tested. This last function is not implemented for
Windows platforms. \texttt{exseq()} is an alias for \texttt{extractseqs()}.

The timings thereafter were from an home-ADSL connection, and are only indicative.
For this chapter we set up the bank to \texttt{emblTP} which is a frozen
subset of the EMBL database to allow for the reproducibility of results.

\begin{Schunk}
\begin{Sinput}
 (tcb <- system.time(choosebank("emblTP")))
\end{Sinput}
\begin{Soutput}
utilisateur     système      écoulé 
      0.084       0.003       5.445 
\end{Soutput}
\end{Schunk}

It was then about 5 
seconds to select the relevant database.

\section{Extacting 78,573 complete human nuclear CDS}

We suppose that the sequences we are interested in 
are all the complete coding sequences from \textit{Homo sapiens} that
are encoded in the nucleus (we don't want sequences from human mitochondrion). 

\begin{Schunk}
\begin{Sinput}
 (tqu <- system.time(query("hsCDS", "sp=Homo sapiens AND t=cds AND o=nuclear AND NOT k=partial", 
     virtual = TRUE)))
\end{Sinput}
\begin{Soutput}
utilisateur     système      écoulé 
      0.000       0.000      10.979 
\end{Soutput}
\begin{Sinput}
 (nseq <- hsCDS$nelem)
\end{Sinput}
\begin{Soutput}
[1] 78573
\end{Soutput}
\begin{Sinput}
 (tex <- system.time(mycds <- extractseqs("hsCDS")))
\end{Sinput}
\begin{Soutput}
utilisateur     système      écoulé 
      8.084       1.206      51.703 
\end{Soutput}
\end{Schunk}
 
We have used a virtual query to speed up things:
it was about 11 seconds 
to create on the server a list of 78573
sequences. We have downloaded the sequences in zlib compressed mode:
it was about 52 seconds
to dowload the sequences in the object \texttt{mycds}, which looks like :

\begin{Schunk}
\begin{Sinput}
 cat(head(mycds), sep = "\n")
\end{Sinput}
\begin{Soutput}
>A00127.PE1             2217 residues
ATGCGGGGTCCGAGCGGGGCTCTGTGGCTGCTCCTGGCTCTGCGCACCGTGCTCGGAGGC
ATGGAGGTGCGGTGGTGCGCCACCTCGGACCCAGAGCAGCACAAGTGCGGCAACATGAGC
GAGGCCTTCCGGGAAGCGGGCATCCAGCCCTCCCTCCTCTGCGTCCGGGGCACCTCCGCC
GACCACTGCGTCCAGCTCATCGCGGCCCAGGAGGCTGACGCCATCACTCTGGATGGAGGA
GCCATCTATGAGGCGGGAAAGGAGCACGGCCTGAAGCCGGTGGTGGGCGAAGTGTACGAT
\end{Soutput}
\begin{Sinput}
 cat(tail(mycds), sep = "\n")
\end{Sinput}
\begin{Soutput}
ATCACTGCGGCCCCAGAGAGAGAGGGCATAGGCCACGGCGGCCCCAAGCTATGCTGCACA
CTGAGCTCCCTCAGCTCCGCTGCTGAGACTGGCCGGGACCCGCTGGACAGCGAGGAGGAG
GCAACCAGCGGCGCCCAGGATGAACGTGGCCTGAAGCCGCCTTCCCGGGGCCAGTTTCCT
TCCCTCTCAGCCAGGGATGCCTCGAGCAGCCACAGGGGCAGGAACGTCCTGACTGCCATC
CTGCTGCTGCTGCGGGAGCTGGATGCAGAGGGGCTGGAGGCCGTGCAGCAGACTGTGGGC
AGCCGGCTGCAGGCCCTGCGTGGGGAAGAGGTGCAGGAGCACGCCGAGTGA
\end{Soutput}
\end{Schunk}

We save now the sequences in a local FASTA file for future use:

\begin{Schunk}
\begin{Sinput}
 (twl <- system.time(writeLines(mycds, "mycds.fasta")))
\end{Sinput}
\begin{Soutput}
utilisateur     système      écoulé 
      3.407       0.874       4.452 
\end{Soutput}
\end{Schunk}

It was then about 4 seconds
to dump the sequences on a local file. We read the sequences as strings
without setting attributes to save time:

\begin{Schunk}
\begin{Sinput}
 (trf <- system.time(mycdss <- read.fasta("mycds.fasta", as.string = TRUE, 
     set.attributes = FALSE)))
\end{Sinput}
\begin{Soutput}
utilisateur     système      écoulé 
     26.903       0.518      28.581 
\end{Soutput}
\end{Schunk}

It was then about 29 seconds
to read the sequences as strings. We save them in XDR format:

\begin{Schunk}
\begin{Sinput}
 (tsrd <- system.time(save(mycdss, file = "mycdss.RData")))
\end{Sinput}
\begin{Soutput}
utilisateur     système      écoulé 
     38.797       0.335      40.009 
\end{Soutput}
\end{Schunk}

It was then about 40 seconds
to save the sequences in XDR format. How long is it to load the sequences
from XDR format?

\begin{Schunk}
\begin{Sinput}
 (tlrd <- system.time(load("mycdss.RData")))
\end{Sinput}
\begin{Soutput}
utilisateur     système      écoulé 
      1.738       0.041       1.800 
\end{Soutput}
\end{Schunk}

It was then about 2 seconds
to load the sequences from an XDR formated file. 

\section{Extacting 78,573 complete human nuclear Proteins}

Now, we also want the corresponding proteins. We download the translated 
CDS from the server:

\begin{Schunk}
\begin{Sinput}
 (texp <- system.time(myprot <- extractseqs("hsCDS", operation = "translate")))
\end{Sinput}
\begin{Soutput}
utilisateur     système      écoulé 
      3.262       0.681      58.252 
\end{Soutput}
\end{Schunk}

It was then about 58 seconds
to get the protein sequences from the server. The object \texttt{myprot} looks
like:

\begin{Schunk}
\begin{Sinput}
 cat(head(myprot), sep = "\n")
\end{Sinput}
\begin{Soutput}
>A00127.PE1              739 residues
MRGPSGALWLLLALRTVLGGMEVRWCATSDPEQHKCGNMSEAFREAGIQPSLLCVRGTSA
DHCVQLIAAQEADAITLDGGAIYEAGKEHGLKPVVGEVYDQEVGTSYYAVAVVRRSSHVT
IDTLKGVKSCHTGINRTVGWNVPVGYLVESGRLSVMGCDVLKAVSDYFGGSCVPGAGETS
YSESLCRLCRGDSSGEGVCDKSPLERYYDYSGAFRCLAEGAGDVAFVKHSTVLENTDGKT
LPSWGQALLSQDFELLCRDGSRADVTEWRQCHLARVPAHAVVVRADTDGGLIFRLLNEGQ
\end{Soutput}
\begin{Sinput}
 cat(tail(myprot), sep = "\n")
\end{Sinput}
\begin{Soutput}
>Z93322.PE1              257 residues
MKLTRKMVLTRAKASELHSVRKLNCWGSRLTDISICQEMPSLEVITLSVNSISTLEPVSR
CQRLSELYLRRNRIPSLAELFYLKGLPRLRVLWLAENPCCGTSPHRYRMTVLRTLPRLQK
LDNQAVTEEELSRALSEGEEITAAPEREGIGHGGPKLCCTLSSLSSAAETGRDPLDSEEE
ATSGAQDERGLKPPSRGQFPSLSARDASSSHRGRNVLTAILLLLRELDAEGLEAVQQTVG
SRLQALRGEEVQEHAE*
\end{Soutput}
\end{Schunk}

We save the protein sequences in a local FASTA file for future use:

\begin{Schunk}
\begin{Sinput}
 (twl2 <- system.time(writeLines(myprot, "myprot.fasta")))
\end{Sinput}
\begin{Soutput}
utilisateur     système      écoulé 
      1.256       0.306       1.580 
\end{Soutput}
\end{Schunk}

It was then about 2 seconds
to dump the protein sequences on a local file. We read the sequences as strings
without setting attributes to save time:

\begin{Schunk}
\begin{Sinput}
 (trf2 <- system.time(myprots <- read.fasta("myprot.fasta", 
     as.string = TRUE, set.attributes = FALSE)))
\end{Sinput}
\begin{Soutput}
utilisateur     système      écoulé 
     14.861       0.147      15.217 
\end{Soutput}
\end{Schunk}

It was then about 15 seconds
to read the protein sequences as strings. We save them in XDR format:

\begin{Schunk}
\begin{Sinput}
 (tsrd2 <- system.time(save(myprots, file = "myprots.RData")))
\end{Sinput}
\begin{Soutput}
utilisateur     système      écoulé 
      3.795       0.166       4.005 
\end{Soutput}
\end{Schunk}

It was then about 4 seconds
to save the protein sequences in XDR format. How long is it to load the 
protein sequences from XDR format?

\begin{Schunk}
\begin{Sinput}
 (tlrd2 <- system.time(load("myprots.RData")))
\end{Sinput}
\begin{Soutput}
utilisateur     système      écoulé 
      1.022       0.025       1.056 
\end{Soutput}
\end{Schunk}

It was then about 1 seconds
to load the protein sequences from an XDR formated file.

\section{Sanity check}

As a quick sanity check, we plot the distribution of protein size:

\setkeys{Gin}{width=\textwidth}

\begin{Schunk}
\begin{Sinput}
 x <- log10(nchar(myprots) - 1)
 dstx <- density(x)
 plot(dstx, main = paste("Protein size distribution in the human genome\nn = ", 
     length(myprots), "proteins"), xlab = "Number of amino-acids in log 10 scale", 
     las = 1)
 polycurve <- function(x, y, base.y = min(y), ...) polygon(x = c(min(x), 
     x, max(x)), y = c(base.y, y, base.y), ...)
 polycurve(dstx$x, dstx$y, col = "yellow")
\end{Sinput}
\end{Schunk}
\includegraphics{../figs/extractseqs-protsizeinhuman}

\begin{Schunk}
\begin{Sinput}
 closebank()
\end{Sinput}
\end{Schunk}


\section*{Session Informations}

This part was compiled under the following \Rlogo{}~environment:

\begin{itemize}
  \item R version 2.6.2 (2008-02-08), \verb|i386-apple-darwin8.10.1|
  \item Locale: \verb|fr_FR.UTF-8/fr_FR.UTF-8/fr_FR.UTF-8/C/C/C|
  \item Base packages: base, datasets, grDevices, graphics, methods,
    stats, utils
  \item Other packages: MASS~7.2-40, ade4~1.4-5, ape~2.1-1,
    nlme~3.1-86, seqinr~1.1-6, xtable~1.5-2
  \item Loaded via a namespace (and not attached): grid~2.6.2,
    lattice~0.17-4, rcompgen~0.1-17
\end{itemize}
There were two compilation steps:

\begin{itemize}
  \item \Rlogo{} compilation time was: Sun Feb 24 15:53:07 2008
  \item \LaTeX{} compilation time was: \today
\end{itemize}

% END - DO NOT REMOVE THIS LINE

%%%%%%%%%%%%  BIBLIOGRAPHY %%%%%%%%%%%%%%%%%
\clearpage
\addcontentsline{toc}{section}{References}
\bibliographystyle{plain}
\bibliography{../config/book}
\end{document}
